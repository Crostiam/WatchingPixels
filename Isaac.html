<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>The Binding of Isaac - Enhanced</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #333;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: Arial, sans-serif;
        color: #fff;
      }

      canvas {
        background-color: #111;
        border: 2px solid #555;
      }

      #gameContainer {
        display: flex;
      }

      #sidebar {
        margin-left: 20px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-start;
        max-width: 260px;
      }

      #sidebar h3 {
        margin: 8px 0 6px;
      }

      #playerStats {
        margin-bottom: 16px;
      }

      #playerItems ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      #playerItems li {
        margin-bottom: 5px;
      }

      .item-notification {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 15px 25px;
        border-radius: 10px;
        text-align: center;
        font-size: 18px;
        border: 2px solid #3498db;
        opacity: 1;
        transition: opacity 0.5s ease-in-out;
        z-index: 1000;
        max-width: 320px;
        box-shadow: 0 0 20px rgba(52, 152, 219, 0.5);
      }

      #itemList {
        max-height: 150px;
        overflow-y: auto;
        width: 100%;
      }

      .muted {
        color: #bbb;
        font-size: 12px;
      }
    </style>
  </head>

  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="600" height="600" aria-label="Game canvas"></canvas>

      <div id="sidebar">
        <div id="playerStats">
          <h3>Player Stats</h3>
          <div>Health: <span id="health">3</span></div>
          <div>Floor: <span id="floor">1</span></div>
          <div>Score: <span id="score">0</span></div>
        </div>

        <div id="map">
          <h3>Map</h3>
          <div class="muted">Explore rooms. Doors lock until cleared.</div>
        </div>

        <div id="playerItems">
          <h3>Items</h3>
          <div id="itemList"></div>
        </div>
      </div>
    </div>

    <script>
      // Canvas
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // Game state
      const game = {
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 15,
          speed: 4,
          maxHealth: 3,
          health: 3,
          damage: 1,
          tearDelay: 300,
          tearSpeed: 8,
          tearSize: 5,
          range: 600,
          color: "#3498db",
          direction: { x: 0, y: 0 },
          lastShot: 0,
          items: [],
          invincible: 0,
          shotType: "single",
          spreadCount: 1,
          tripleCount: 1,
          shield: false,
          roomEntryTime: 0,
          luck: false
        },
        bullets: [],
        enemies: [],
        rooms: [],
        currentRoom: { x: 1, y: 1 },
        items: [],
        boss: null,
        keys: {},
        shootingDirections: {},
        lastAutoShot: 0,
        score: 0,
        floor: 1,
        gameOver: false,
        roomCleared: false,
        lastDamageTime: 0,
        damageCooldown: 1000,
        currentTime: 0,
        roomClearedTime: 0,
        lastInteractTime: 0,
        interactCooldown: 200,
        lastDoorDirection: null,
        bossDefeated: false
      };

      // Room types
      const ROOM_TYPES = {
        NORMAL: 0,
        TREASURE: 1,
        BOSS: 2
      };

      // Items
      const ITEMS = {
        HP_UP: {
          name: "HP Up",
          description: "+1 Max Health",
          type: "passive",
          color: "#e74c3c",
          effect: (player) => {
            player.maxHealth++;
            player.health++;
            updateHUD();
            updateItemList();
          }
        },
        TEARS_UP: {
          name: "Tears Up",
          description: "Faster shooting",
          type: "passive",
          color: "#3498db",
          effect: (player) => {
            player.tearDelay = Math.max(100, player.tearDelay * 0.85);
            updateItemList();
          }
        },
        DAMAGE_UP: {
          name: "Damage Up",
          description: "+1 Damage",
          type: "passive",
          color: "#f1c40f",
          effect: (player) => {
            player.damage++;
            updateItemList();
          }
        },
        TRIPLE_SHOT: {
          name: "Triple Shot",
          description: "Shoot 3 tears in sequence",
          type: "passive",
          color: "#9b59b6",
          effect: (player) => {
            player.tripleCount = 3;
            player.shotType = player.shotType === "spread" ? "spread_triple" : "triple";
            updateItemList();
          }
        },
        SPREAD_SHOT: {
          name: "Spread Shot",
          description: "+2 projectiles to each side",
          type: "passive",
          color: "#2ecc71",
          effect: (player) => {
            player.spreadCount += 2;
            player.shotType = player.shotType === "triple" ? "spread_triple" : "spread";
            updateItemList();
          }
        },
        SHIELD: {
          name: "Wooden Shield",
          description: "Blocks one hit",
          type: "consumable",
          color: "#3498db",
          effect: (player) => {
            player.shield = true;
            updateItemList();
          }
        },
        LUCKY_FOOT: {
          name: "Lucky Foot",
          description: "Better item chances",
          type: "passive",
          color: "#f39c12",
          effect: (player) => {
            player.luck = true;
            updateItemList();
          }
        },
        MAGIC_MUSHROOM: {
          name: "Magic Mushroom",
          description: "All stats up!",
          type: "passive",
          color: "#e74c3c",
          effect: (player) => {
            player.damage += 1;
            player.maxHealth += 1;
            player.health += 1;
            player.speed += 0.5;
            player.tearDelay = Math.max(100, player.tearDelay * 0.8);
            updateItemList();
          }
        }
      };

      // Enemies
      const ENEMIES = {
        BASIC: {
          name: "Fly",
          health: 2,
          speed: 1.5,
          radius: 12,
          color: "#e74c3c",
          value: 10,
          behavior: "chase",
          direction: { x: 0, y: 0 }
        },
        SPITTER: {
          name: "Spitter",
          health: 3,
          speed: 1,
          radius: 14,
          color: "#9b59b6",
          value: 20,
          behavior: "shoot",
          shootDelay: 2000,
          lastShot: 0,
          direction: { x: 0, y: 0 }
        },
        CHARGER: {
          name: "Charger",
          health: 5,
          speed: 3,
          radius: 16,
          color: "#f39c12",
          value: 30,
          behavior: "charge",
          chargeDelay: 2000,
          lastCharge: 0
        }
      };

      // Bosses
      const BOSSES = {
        MONSTRO: {
          name: "Monstro",
          health: 30,
          speed: 1,
          radius: 30,
          color: "#c0392b",
          value: 200,
          behavior: "jump",
          jumpDelay: 3000,
          lastJump: 0,
          shootDelay: 1500,
          lastShot: 0,
          direction: { x: 0, y: 0 }
        },
        GURDY: {
          name: "Gurdy Jr.",
          health: 40,
          speed: 2.5,
          radius: 35,
          color: "#8e44ad",
          value: 300,
          behavior: "dash",
          dashDelay: 1500,
          lastDash: 0,
          direction: { x: 0, y: 0 }
        }
      };

      // Controls
      const keyMap = {
        65: "left", // A
        87: "up", // W
        68: "right", // D
        83: "down", // S
        82: "restart", // R
        69: "interact" // E
      };

      // Shooting directions (Arrow keys)
      const shootDirections = {
        37: { x: -1, y: 0 }, // left
        38: { x: 0, y: -1 }, // up
        39: { x: 1, y: 0 }, // right
        40: { x: 0, y: 1 } // down
      };

      // Input listeners
      window.addEventListener("keydown", (e) => {
        // prevent scroll for arrows/space
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(e.key)) {
          e.preventDefault();
        }

        if (keyMap[e.keyCode]) {
          game.keys[keyMap[e.keyCode]] = true;
        }

        if (shootDirections[e.keyCode]) {
          game.shootingDirections[e.keyCode] = true;
          const dir = shootDirections[e.keyCode];
          game.player.direction = { x: dir.x, y: dir.y };
          shoot(dir.x, dir.y);
        }

        if (e.keyCode === 69) {
          game.keys["interact"] = true;
          // Do not set lastInteractTime here; set it when we actually pick up
        }
      });

      window.addEventListener("keyup", (e) => {
        if (keyMap[e.keyCode]) {
          game.keys[keyMap[e.keyCode]] = false;
        }

        if (shootDirections[e.keyCode]) {
          game.shootingDirections[e.keyCode] = false;
        }

        if (e.keyCode === 69) {
          game.keys["interact"] = false;
        }
      });

      // Init
      function initGame() {
        game.player = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 15,
          speed: 4,
          maxHealth: 3,
          health: 3,
          damage: 1,
          tearDelay: 300,
          tearSpeed: 8,
          tearSize: 5,
          range: 600,
          color: "#3498db",
          direction: { x: 0, y: 0 },
          lastShot: 0,
          items: [],
          invincible: 0,
          shotType: "single",
          spreadCount: 1,
          tripleCount: 1,
          shield: false,
          roomEntryTime: performance.now(),
          luck: false
        };

        game.bullets = [];
        game.enemies = [];
        game.rooms = [];
        game.items = [];
        game.boss = null;
        game.keys = {};
        game.shootingDirections = {};
        game.score = 0;
        game.floor = 1;
        game.gameOver = false;
        game.roomCleared = false;
        game.lastDamageTime = 0;
        game.lastAutoShot = 0;
        game.currentTime = performance.now();
        game.roomClearedTime = 0;
        game.lastDoorDirection = null;
        game.bossDefeated = false;

        generateFloor();
        spawnPlayerInRoom();

        updateHUD();
        updateMap();
        updateItemList();
      }

      // Floor generation
      function generateFloor() {
        game.rooms = [];
        game.currentRoom = { x: 1, y: 1 };
        game.bossDefeated = false;

        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const type = ROOM_TYPES.NORMAL;
            game.rooms.push({
              x,
              y,
              type,
              cleared: x === 1 && y === 1 // start room cleared (doors open)
            });
          }
        }

        // Treasure room (not center)
        const nonCenter = game.rooms.filter((r) => !(r.x === 1 && r.y === 1));
        const treasureRoom = nonCenter[Math.floor(Math.random() * nonCenter.length)];
        treasureRoom.type = ROOM_TYPES.TREASURE;

        // Boss room (not center and not treasure)
        const possibleBossRooms = nonCenter.filter((r) => r !== treasureRoom);
        if (possibleBossRooms.length > 0) {
          const randomBossRoom = possibleBossRooms[Math.floor(Math.random() * possibleBossRooms.length)];
          randomBossRoom.type = ROOM_TYPES.BOSS;
        }

        updateMap();
      }

      function getRandomBoss() {
        const bosses = Object.values(BOSSES);
        const randomBoss = bosses[Math.floor(Math.random() * bosses.length)];
        return JSON.parse(JSON.stringify(randomBoss));
      }

      function getCurrentRoom() {
        return game.rooms.find((r) => r.x === game.currentRoom.x && r.y === game.currentRoom.y);
      }

      // Spawning
      function spawnPlayerInRoom() {
        const room = getCurrentRoom();
        const margin = 50;

        // Position at the door entered from
        if (game.lastDoorDirection) {
          if (game.lastDoorDirection.dx === -1) {
            game.player.x = margin;
            game.player.y = canvas.height / 2;
          } else if (game.lastDoorDirection.dx === 1) {
            game.player.x = canvas.width - margin;
            game.player.y = canvas.height / 2;
          } else if (game.lastDoorDirection.dy === -1) {
            game.player.x = canvas.width / 2;
            game.player.y = margin;
          } else if (game.lastDoorDirection.dy === 1) {
            game.player.x = canvas.width / 2;
            game.player.y = canvas.height - margin;
          }
        } else {
          game.player.x = canvas.width / 2;
          game.player.y = canvas.height / 2;
        }

        game.enemies = [];
        game.items = [];
        game.roomCleared = false;
        game.player.roomEntryTime = performance.now();

        if (!room.cleared) {
          spawnEnemiesForRoom(room);

          if (room.type === ROOM_TYPES.BOSS && !game.bossDefeated) {
            game.boss = getRandomBoss();

            // spawn boss away from player
            let safe = false;
            let attempts = 0;
            while (!safe && attempts < 100) {
              game.boss.x = margin + Math.random() * (canvas.width - 2 * margin);
              game.boss.y = margin + Math.random() * (canvas.height - 2 * margin);
              const dx = game.player.x - game.boss.x;
              const dy = game.player.y - game.boss.y;
              const distance = Math.hypot(dx, dy);
              if (distance > game.player.radius + game.boss.radius + 50) {
                safe = true;
              }
              attempts++;
            }
            game.boss.direction = { x: 0, y: 0 };
            game.boss.lastJump = 0;
            game.boss.lastShot = 0;
          }
        } else if ( room.type === ROOM_TYPES.BOSS && game.bossDefeated ) {
          // Keep trapdoor if boss already defeated
          const hasTrapdoor = game.items.some((i) => i.type === "trapdoor");
          if (!hasTrapdoor) {
            game.items.push({
              x: canvas.width / 2,
              y: canvas.height / 2 + 50,
              radius: 20,
              color: "#7f8c8d",
              type: "trapdoor"
            });
          }
        }
      }

      function spawnEnemiesForRoom(room) {
        if (room.type === ROOM_TYPES.BOSS) {
          return; // handled in spawnPlayerInRoom
        } else if (room.type === ROOM_TYPES.TREASURE) {
          if (!room.cleared) {
            // Treasure items (no direct HP-only item)
            const treasureItems = [
              ITEMS.LUCKY_FOOT,
              ITEMS.MAGIC_MUSHROOM,
              ITEMS.SPREAD_SHOT,
              ITEMS.TRIPLE_SHOT
            ];
            const randomItem = treasureItems[Math.floor(Math.random() * treasureItems.length)];
            spawnItem(randomItem, canvas.width / 2, canvas.height / 2, 15);
          }
        } else {
          const enemyCount = 5 + Math.floor(Math.random() * 3) + game.floor;
          for (let i = 0; i < enemyCount; i++) {
            const enemyTypes = Object.values(ENEMIES);
            const enemy = JSON.parse(
              JSON.stringify(enemyTypes[Math.floor(Math.random() * enemyTypes.length)])
            );

            // initial direction
            enemy.direction = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
            const len = Math.hypot(enemy.direction.x, enemy.direction.y) || 1;
            enemy.direction.x /= len;
            enemy.direction.y /= len;

            // spawn near edges but not on the player
            let safe = false;
            let attempts = 0;
            while (!safe && attempts < 10) {
              if (Math.random() < 0.5) {
                enemy.x = Math.random() < 0.5 ? 50 : canvas.width - 50;
                enemy.y = 50 + Math.random() * (canvas.height - 100);
              } else {
                enemy.x = 50 + Math.random() * (canvas.width - 100);
                enemy.y = Math.random() < 0.5 ? 50 : canvas.height - 50;
              }
              const dx = game.player.x - enemy.x;
              const dy = game.player.y - enemy.y;
              const distance = Math.hypot(dx, dy);
              if (distance > game.player.radius + enemy.radius + 30) safe = true;
              attempts++;
            }

            game.enemies.push(enemy);
          }
        }

        updateMap();
      }

      function changeRoom(dx, dy) {
        const newX = game.currentRoom.x + dx;
        const newY = game.currentRoom.y + dy;
        if (newX >= 0 && newX < 3 && newY >= 0 && newY < 3) {
          game.currentRoom = { x: newX, y: newY };
          game.player.direction = { x: 0, y: 0 };
          game.bullets = [];
          game.lastDoorDirection = { dx: -dx, dy: -dy };
          spawnPlayerInRoom();
          updateMap();
        }
      }

      // Shooting
      function shoot(dx, dy) {
        const now = performance.now();
        if (now - game.player.lastShot < game.player.tearDelay) return;

        game.player.lastShot = now;
        game.lastAutoShot = now;

        switch (game.player.shotType) {
          case "single":
            createBullet(game.player.x, game.player.y, dx, dy, "player");
            break;

          case "triple":
            for (let i = 0; i < game.player.tripleCount; i++) {
              setTimeout(() => {
                createBullet(game.player.x, game.player.y, dx, dy, "player");
              }, i * 50);
            }
            break;

          case "spread": {
            createBullet(game.player.x, game.player.y, dx, dy, "player");
            const angle = Math.atan2(dy, dx);
            for (let i = 1; i <= game.player.spreadCount; i++) {
              const spreadAngle = i * 0.2;
              createBullet(
                game.player.x,
                game.player.y,
                Math.cos(angle + spreadAngle),
                Math.sin(angle + spreadAngle),
                "player"
              );
              createBullet(
                game.player.x,
                game.player.y,
                Math.cos(angle - spreadAngle),
                Math.sin(angle - spreadAngle),
                "player"
              );
            }
            break;
          }

          case "spread_triple":
            for (let seq = 0; seq < game.player.tripleCount; seq++) {
              setTimeout(() => {
                createBullet(game.player.x, game.player.y, dx, dy, "player");
                const angle = Math.atan2(dy, dx);
                for (let i = 1; i <= game.player.spreadCount; i++) {
                  const spreadAngle = i * 0.2;
                  createBullet(
                    game.player.x,
                    game.player.y,
                    Math.cos(angle + spreadAngle),
                    Math.sin(angle + spreadAngle),
                    "player"
                  );
                  createBullet(
                    game.player.x,
                    game.player.y,
                    Math.cos(angle - spreadAngle),
                    Math.sin(angle - spreadAngle),
                    "player"
                  );
                }
              }, seq * 50);
            }
            break;
        }
      }

      function createBullet(x, y, dx, dy, owner) {
        const offsetX = dx * game.player.radius * 1.2;
        const offsetY = dy * game.player.radius * 1.2;
        game.bullets.push({
          x: x + offsetX,
          y: y + offsetY,
          radius: game.player.tearSize,
          speed: game.player.tearSpeed,
          dx,
          dy,
          color: owner === "player" ? "#f1c40f" : "#9b59b6",
          distance: 0,
          maxDistance: game.player.range,
          damage: game.player.damage,
          owner,
          creationTime: performance.now()
        });
      }

      // Items: helpers
      function spawnItem(def, x, y, radius = 15) {
        game.items.push({
          ...def,
          x,
          y,
          radius
        });
      }

      function spawnRandomItem(x, y, name) {
        // Map simple names to item defs
        const map = {
          Shield: ITEMS.SHIELD
        };
        const def = map[name];
        if (def) spawnItem(def, x, y, 15);
      }

      // Room clear
      function checkRoomCleared() {
        const room = getCurrentRoom();
        const noEnemies = game.enemies.length === 0;
        const bossDead = !game.boss || game.boss.health <= 0;

        if (noEnemies && bossDead && !room.cleared) {
          room.cleared = true;
          game.roomCleared = true;
          game.roomClearedTime = game.currentTime;

          // Normal room: shield-only drop (fixed: actually spawn the item)
          if (room.type === ROOM_TYPES.NORMAL) {
            spawnRandomItem(
              canvas.width / 2 + Math.random() * 100 - 50,
              canvas.height / 2 + Math.random() * 100 - 50,
              "Shield"
            );
          }

          // Boss room: reward and trapdoor
          if (room.type === ROOM_TYPES.BOSS && !game.bossDefeated) {
            game.bossDefeated = true;
            const drops = [
              {
                ...ITEMS.TEARS_UP,
                name: "Speed Up",
                description: "+0.5 Speed",
                effect: (player) => {
                  player.speed += 0.5;
                }
              }
            ];
            const drop = drops[Math.floor(Math.random() * drops.length)];
            spawnItem(drop, canvas.width / 2, canvas.height / 2, 15);

            // Trapdoor
            game.items.push({
              x: canvas.width / 2,
              y: canvas.height / 2 + 50,
              radius: 20,
              color: "#7f8c8d",
              type: "trapdoor"
            });
          }

          updateMap();
        }
      }

      function nextFloor() {
        game.floor++;
        document.getElementById("floor").textContent = game.floor;
        generateFloor();
        spawnPlayerInRoom();
      }

      // Map / UI
      function updateMap() {
        let mapHTML = `<div style="margin-bottom:5px">Map (F${game.floor})</div>`;
        for (let y = 0; y < 3; y++) {
          for (let x = 0; x < 3; x++) {
            const room = game.rooms.find((r) => r.x === x && r.y === y);
            let roomChar = "?";
            let roomColor = "#777";
            if (room) {
              if (room.x === game.currentRoom.x && room.y === game.currentRoom.y) {
                roomChar = "★";
                roomColor = "#ff0";
              } else if (room.cleared) {
                roomChar = room.type === ROOM_TYPES.BOSS ? "B" : room.type === ROOM_TYPES.TREASURE ? "T" : "C";
                roomColor = "#0f0";
              } else if (isAdjacentRoom(x, y)) {
                roomChar = room.type === ROOM_TYPES.BOSS ? "B" : room.type === ROOM_TYPES.TREASURE ? "T" : "?";
                roomColor = "#fff";
              }
            }
            mapHTML += `<span style="color:${roomColor}; margin:0 3px">${roomChar}</span>`;
          }
          mapHTML += "<br>";
        }
        document.getElementById("map").innerHTML = mapHTML;
      }

      function updateItemList() {
        const itemList = document.getElementById("itemList");
        itemList.innerHTML = "";
        if (game.player.items.length === 0) {
          const empty = document.createElement("div");
          empty.textContent = "No items yet";
          empty.className = "muted";
          itemList.appendChild(empty);
          return;
        }
        game.player.items.forEach((item) => {
          const li = document.createElement("div");
          li.textContent = `${item.name}: ${item.description}`;
          li.style.color = item.color || "#fff";
          itemList.appendChild(li);
        });
      }

      function isAdjacentRoom(x, y) {
        return (
          (Math.abs(x - game.currentRoom.x) === 1 && y === game.currentRoom.y) ||
          (Math.abs(y - game.currentRoom.y) === 1 && x === game.currentRoom.x)
        );
      }

      function showItemNotification(name, description) {
        const notification = document.createElement("div");
        notification.className = "item-notification";
        notification.innerHTML = `<strong>Picked up: ${name}</strong><br>${description}`;
        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.opacity = "0";
          setTimeout(() => {
            notification.remove();
          }, 500);
        }, 2000);
      }

      function updateHUD() {
        document.getElementById("health").textContent = game.player.health;
        document.getElementById("floor").textContent = game.floor;
        document.getElementById("score").textContent = game.score;
      }

      // Update loop
      function update() {
        const now = performance.now();
        game.currentTime = now;

        if (game.gameOver) {
          if (game.keys["restart"]) {
            initGame();
          }
          return;
        }

        // Movement
        game.player.direction = { x: 0, y: 0 };
        if (game.keys["left"]) game.player.direction.x = -1;
        if (game.keys["right"]) game.player.direction.x = 1;
        if (game.keys["up"]) game.player.direction.y = -1;
        if (game.keys["down"]) game.player.direction.y = 1;

        if (game.player.direction.x !== 0 && game.player.direction.y !== 0) {
          game.player.direction.x *= 0.7071;
          game.player.direction.y *= 0.7071;
        }

        game.player.x += game.player.direction.x * game.player.speed;
        game.player.y += game.player.direction.y * game.player.speed;

        // Doors (locked until room cleared)
        const margin = 30;
        const doorWidth = 60;
        const room = getCurrentRoom();
        const canExit = !!room.cleared;

        if (
          canExit &&
          game.player.x < margin &&
          game.player.y > canvas.height / 2 - doorWidth / 2 &&
          game.player.y < canvas.height / 2 + doorWidth / 2
        ) {
          changeRoom(-1, 0);
        }
        if (
          canExit &&
          game.player.x > canvas.width - margin &&
          game.player.y > canvas.height / 2 - doorWidth / 2 &&
          game.player.y < canvas.height / 2 + doorWidth / 2
        ) {
          changeRoom(1, 0);
        }
        if (
          canExit &&
          game.player.y < margin &&
          game.player.x > canvas.width / 2 - doorWidth / 2 &&
          game.player.x < canvas.width / 2 + doorWidth / 2
        ) {
          changeRoom(0, -1);
        }
        if (
          canExit &&
          game.player.y > canvas.height - margin &&
          game.player.x > canvas.width / 2 - doorWidth / 2 &&
          game.player.x < canvas.width / 2 + doorWidth / 2
        ) {
          changeRoom(0, 1);
        }

        // Keep inside room bounds
        game.player.x = Math.max(margin, Math.min(canvas.width - margin, game.player.x));
        game.player.y = Math.max(margin, Math.min(canvas.height - margin, game.player.y));

        if (game.player.invincible > 0) {
          game.player.invincible--;
        }

        // Auto-shooting (rate limited)
        const anyShoot = Object.keys(game.shootingDirections).some((k) => game.shootingDirections[k]);
        if (anyShoot && now - game.lastAutoShot > game.player.tearDelay) {
          game.lastAutoShot = now;
          for (const keyCode in game.shootingDirections) {
            if (game.shootingDirections[keyCode]) {
              const dir = shootDirections[keyCode];
              game.player.direction = { x: dir.x, y: dir.y };
              shoot(dir.x, dir.y);
              break;
            }
          }
        }

        // Bullets
        for (let i = game.bullets.length - 1; i >= 0; i--) {
          const b = game.bullets[i];
          b.x += b.dx * b.speed;
          b.y += b.dy * b.speed;
          b.distance += b.speed;

          if (
            b.distance > b.maxDistance ||
            b.x < 0 ||
            b.x > canvas.width ||
            b.y < 0 ||
            b.y > canvas.height
          ) {
            game.bullets.splice(i, 1);
            continue;
          }

          if (b.owner === "player") {
            // enemies
            let hitSomething = false;
            for (let j = game.enemies.length - 1; j >= 0; j--) {
              const e = game.enemies[j];
              const dx = b.x - e.x;
              const dy = b.y - e.y;
              if (Math.hypot(dx, dy) < b.radius + e.radius) {
                e.health -= b.damage;
                game.bullets.splice(i, 1);
                if (e.health <= 0) {
                  game.score += e.value;
                  game.enemies.splice(j, 1);
                  updateHUD();
                }
                hitSomething = true;
                break;
              }
            }
            if (!hitSomething && game.boss) {
              const dx = b.x - game.boss.x;
              const dy = b.y - game.boss.y;
              if (Math.hypot(dx, dy) < b.radius + game.boss.radius) {
                game.boss.health -= b.damage;
                game.bullets.splice(i, 1);
                if (game.boss.health <= 0) {
                  game.score += game.boss.value;
                  game.boss = null;
                  checkRoomCleared();
                  updateHUD();
                }
              }
            }
          } else if (b.owner === "enemy") {
            const dx = b.x - game.player.x;
            const dy = b.y - game.player.y;
            if (
              Math.hypot(dx, dy) < b.radius + game.player.radius &&
              game.player.invincible === 0 &&
              now - game.lastDamageTime > game.damageCooldown
            ) {
              if (game.player.shield) {
                game.player.shield = false;
              } else {
                game.player.health--;
              }
              game.lastDamageTime = now;
              game.player.invincible = 30;
              game.bullets.splice(i, 1);
              updateHUD();
              if (game.player.health <= 0) {
                game.gameOver = true;
              }
            }
          }
        }

        // Enemies
        for (let i = 0; i < game.enemies.length; i++) {
          const enemy = game.enemies[i];

          if (now - game.player.roomEntryTime < 1000) continue;

          if (enemy.behavior === "charge") {
            if (now - enemy.lastCharge > enemy.chargeDelay) {
              enemy.lastCharge = now;
              const dx = game.player.x - enemy.x;
              const dy = game.player.y - enemy.y;
              const d = Math.hypot(dx, dy) || 1;
              enemy.direction = { x: dx / d, y: dy / d };
            }
            enemy.x += enemy.direction.x * enemy.speed;
            enemy.y += enemy.direction.y * enemy.speed;
          } else if (enemy.behavior === "chase") {
            const dx = game.player.x - enemy.x;
            const dy = game.player.y - enemy.y;
            const d = Math.hypot(dx, dy) || 1;
            enemy.x += (dx / d) * enemy.speed;
            enemy.y += (dy / d) * enemy.speed;
          } else if (enemy.behavior === "shoot") {
            if (now - enemy.lastShot > enemy.shootDelay) {
              enemy.lastShot = now;
              const dx = game.player.x - enemy.x;
              const dy = game.player.y - enemy.y;
              const d = Math.hypot(dx, dy) || 1;
              createBullet(enemy.x, enemy.y, dx / d, dy / d, "enemy");
            }
            if (Math.random() < 0.02) {
              enemy.direction = { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 };
            }
            enemy.x += (enemy.direction.x || 0) * enemy.speed;
            enemy.y += (enemy.direction.y || 0) * enemy.speed;
          }

          // bounds
          enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
          enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));

          // collision with player
          const pdx = game.player.x - enemy.x;
          const pdy = game.player.y - enemy.y;
          const pd = Math.hypot(pdx, pdy);
          if (
            pd < game.player.radius + enemy.radius &&
            game.player.invincible === 0 &&
            now - game.lastDamageTime > game.damageCooldown
          ) {
            if (game.player.shield) {
              game.player.shield = false;
            } else {
              game.player.health--;
            }
            game.lastDamageTime = now;
            game.player.invincible = 30;
            updateHUD();

            // knockback
            enemy.x -= (pdx / (pd || 1)) * 20;
            enemy.y -= (pdy / (pd || 1)) * 20;

            if (game.player.health <= 0) {
              game.gameOver = true;
            }
          }
        }

        // Boss
        if (game.boss) {
          const boss = game.boss;

          if (boss.behavior === "jump" && now - boss.lastJump > boss.jumpDelay) {
            boss.lastJump = now;
            const ang = Math.random() * Math.PI * 2;
            const dist = 50 + Math.random() * 100;
            boss.jumpTarget = {
              x: game.player.x + Math.cos(ang) * dist,
              y: game.player.y + Math.sin(ang) * dist
            };
            for (let j = 0; j < 8; j++) {
              const a = (j / 8) * Math.PI * 2;
              createBullet(boss.x, boss.y, Math.cos(a), Math.sin(a), "enemy");
            }
          } else if (boss.behavior === "dash" && now - boss.lastDash > boss.dashDelay) {
            boss.lastDash = now;
            const a = Math.random() * Math.PI * 2;
            boss.direction = { x: Math.cos(a), y: Math.sin(a) };
          }

          if (boss.behavior === "jump" && boss.jumpTarget) {
            const dx = boss.jumpTarget.x - boss.x;
            const dy = boss.jumpTarget.y - boss.y;
            const d = Math.hypot(dx, dy);
            if (d > 10) {
              boss.x += (dx / d) * boss.speed;
              boss.y += (dy / d) * boss.speed;
            } else {
              boss.jumpTarget = null;
            }
          } else if (boss.behavior === "dash") {
            boss.x += boss.direction.x * boss.speed;
            boss.y += boss.direction.y * boss.speed;
            if (boss.x < boss.radius || boss.x > canvas.width - boss.radius) boss.direction.x *= -1;
            if (boss.y < boss.radius || boss.y > canvas.height - boss.radius) boss.direction.y *= -1;
          }

          if (now - boss.lastShot > boss.shootDelay) {
            boss.lastShot = now;
            const dx = game.player.x - boss.x;
            const dy = game.player.y - boss.y;
            const d = Math.hypot(dx, dy) || 1;
            createBullet(boss.x, boss.y, dx / d, dy / d, "enemy");
          }

          const pdx = game.player.x - boss.x;
          const pdy = game.player.y - boss.y;
          const pd = Math.hypot(pdx, pdy);
          if (
            pd < game.player.radius + boss.radius &&
            game.player.invincible === 0 &&
            now - game.lastDamageTime > game.damageCooldown
          ) {
            game.player.health -= 2;
            game.lastDamageTime = now;
            game.player.invincible = 30;
            updateHUD();

            boss.x -= (pdx / (pd || 1)) * 10;
            boss.y -= (pdy / (pd || 1)) * 10;

            if (game.player.health <= 0) {
              game.gameOver = true;
            }
          }
        }

        // Items
        let itemToPickup = null;
        for (let i = 0; i < game.items.length; i++) {
          const item = game.items[i];
          const dx = game.player.x - item.x;
          const dy = game.player.y - item.y;
          if (Math.hypot(dx, dy) < game.player.radius + item.radius) {
            itemToPickup = item;
            break;
          }
        }

        if (itemToPickup && game.keys["interact"] && now - game.lastInteractTime > game.interactCooldown) {
          game.lastInteractTime = now;

          if (itemToPickup.type === "trapdoor") {
            nextFloor();
          } else if (itemToPickup.effect) {
            itemToPickup.effect(game.player);
            game.player.items.push({
              name: itemToPickup.name,
              description: itemToPickup.description,
              type: itemToPickup.type,
              color: itemToPickup.color
            });
            showItemNotification(itemToPickup.name, itemToPickup.description);
            // color flash
            const prevColor = game.player.color;
            game.player.color = itemToPickup.color || prevColor;
            setTimeout(() => {
              game.player.color = prevColor;
            }, 200);
          }

          game.items = game.items.filter((i) => i !== itemToPickup);
          updateItemList();
          updateHUD();
          game.keys["interact"] = false;
        }

        checkRoomCleared();
        document.getElementById("score").textContent = game.score;
      }

      // Render
      function render() {
        // Background gradient
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, "#1a1a1a");
        gradient.addColorStop(1, "#0a0a0a");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Room walls
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 2;
        ctx.strokeRect(30, 30, canvas.width - 60, canvas.height - 60);

        // Door openings (visual) - still visually open; logic locks until cleared
        const doorWidth = 60;
        ctx.clearRect(canvas.width / 2 - doorWidth / 2, 0, doorWidth, 30);
        ctx.clearRect(canvas.width / 2 - doorWidth / 2, canvas.height - 30, doorWidth, 30);
        ctx.clearRect(0, canvas.height / 2 - doorWidth / 2, 30, doorWidth);
        ctx.clearRect(canvas.width - 30, canvas.height / 2 - doorWidth / 2, 30, doorWidth);

        // Bullets
        for (const bullet of game.bullets) {
          const glow = ctx.createRadialGradient(
            bullet.x,
            bullet.y,
            0,
            bullet.x,
            bullet.y,
            bullet.radius * 2
          );
          glow.addColorStop(0, bullet.color);
          glow.addColorStop(1, "rgba(0,0,0,0)");

          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius * 2, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = bullet.color;
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          ctx.fill();
        }

        // Enemies
        for (const enemy of game.enemies) {
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(enemy.x + 3, enemy.y + 5, enemy.radius, enemy.radius / 2, 0, 0, Math.PI * 2);
          ctx.fill();

          // body
          ctx.fillStyle = enemy.color;
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
          ctx.fill();

          // eyes
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(enemy.x - 5, enemy.y - 3, 3, 0, Math.PI * 2);
          ctx.arc(enemy.x + 5, enemy.y - 3, 3, 0, Math.PI * 2);
          ctx.fill();

          // health
          if (enemy.health > 0) {
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.textAlign = "center";
            ctx.fillText(enemy.health, enemy.x, enemy.y + enemy.radius + 15);
          }
        }

        // Boss
        if (game.boss) {
          const boss = game.boss;
          const maxHealth = boss.behavior === "jump" ? BOSSES.MONSTRO.health : BOSSES.GURDY.health;
          const healthPercent = Math.max(0, boss.health / maxHealth);

          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.4)";
          ctx.beginPath();
          ctx.ellipse(boss.x + 5, boss.y + 8, boss.radius, boss.radius / 2, 0, 0, Math.PI * 2);
          ctx.fill();

          // body
          ctx.fillStyle = boss.color;
          ctx.beginPath();
          ctx.arc(boss.x, boss.y, boss.radius, 0, Math.PI * 2);
          ctx.fill();

          // mouth
          ctx.fillStyle = "#8b0000";
          ctx.beginPath();
          ctx.arc(boss.x, boss.y + 10, boss.radius * 0.6, 0.1 * Math.PI, 0.9 * Math.PI);
          ctx.fill();

          // eyes
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(boss.x - 10, boss.y - 10, 8, 0, Math.PI * 2);
          ctx.arc(boss.x + 10, boss.y - 10, 8, 0, Math.PI * 2);
          ctx.fill();

          // health bar
          ctx.fillStyle = "#333";
          ctx.fillRect(boss.x - boss.radius, boss.y - boss.radius - 15, boss.radius * 2, 10);
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(
            boss.x - boss.radius,
            boss.y - boss.radius - 15,
            boss.radius * 2 * healthPercent,
            10
          );

          // name
          ctx.fillStyle = "white";
          ctx.font = "14px Arial";
          ctx.textAlign = "center";
          ctx.fillText(boss.name, boss.x, boss.y - boss.radius - 20);
        }

        // Items
        const nearItem = getItemPlayerIsStandingOn();
        for (const item of game.items) {
          if (!item) continue;

          // glow if near
          if (item === nearItem) {
            const pulse = Math.sin(performance.now() / 200) * 3 + 3;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 + pulse / 10})`;
            ctx.lineWidth = pulse;
            ctx.beginPath();
            ctx.arc(item.x, item.y, item.radius + 8, 0, Math.PI * 2);
            ctx.stroke();
          }

          // body
          ctx.fillStyle = item.color || "#888";
          ctx.beginPath();
          ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
          ctx.fill();

          // icon / text
          if (item.name) {
            if (item === nearItem) {
              ctx.fillStyle = "white";
              ctx.font = "bold 16px Arial";
              ctx.textAlign = "center";
              ctx.fillText("Press E", item.x, item.y - item.radius - 15);

              ctx.font = "italic 14px Arial";
              ctx.fillText(item.name, item.x, item.y + item.radius + 20);
            } else {
              ctx.fillStyle = "white";
              ctx.font = "12px Arial";
              ctx.textAlign = "center";
              if (item.type === "consumable") {
                if (item.name.includes("Shield")) ctx.fillText("🛡", item.x, item.y + 5);
              } else {
                if (item.name.includes("HP")) ctx.fillText("♥", item.x, item.y + 5);
                else if (item.name.includes("Tears") || item.name.includes("Speed"))
                  ctx.fillText("⚡", item.x, item.y + 5);
                else if (item.name.includes("Damage")) ctx.fillText("⚔", item.x, item.y + 5);
                else if (item.name.includes("Triple")) ctx.fillText("3", item.x, item.y + 5);
                else if (item.name.includes("Spread")) ctx.fillText("✸", item.x, item.y + 5);
                else if (item.name.includes("Lucky")) ctx.fillText("🍀", item.x, item.y + 5);
                else if (item.name.includes("Mushroom")) ctx.fillText("🍄", item.x, item.y + 5);
              }
            }
          } else if (item.type === "trapdoor") {
            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.textAlign = "center";
            ctx.fillText("▼", item.x, item.y + 5);
          }
        }

        // Player
        if (game.player.invincible % 10 < 5) {
          // shadow
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.beginPath();
          ctx.ellipse(
            game.player.x + 3,
            game.player.y + 5,
            game.player.radius,
            game.player.radius / 2,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // body
          ctx.fillStyle = game.player.color;
          ctx.beginPath();
          ctx.arc(game.player.x, game.player.y, game.player.radius, 0, Math.PI * 2);
          ctx.fill();

          // face
          let faceAngle = Math.atan2(game.player.direction.y, game.player.direction.x);
          if (game.player.direction.x === 0 && game.player.direction.y === 0) {
            faceAngle = Math.PI / 2;
          }

          // eyes
          const eyeX1 =
            game.player.x + Math.cos(faceAngle) * 8 - Math.sin(faceAngle) * 4;
          const eyeY1 =
            game.player.y + Math.sin(faceAngle) * 8 + Math.cos(faceAngle) * 4;
          const eyeX2 =
            game.player.x + Math.cos(faceAngle) * 8 + Math.sin(faceAngle) * 4;
          const eyeY2 =
            game.player.y + Math.sin(faceAngle) * 8 - Math.cos(faceAngle) * 4;
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, 5, 0, Math.PI * 2);
          ctx.arc(eyeX2, eyeY2, 5, 0, Math.PI * 2);
          ctx.fill();

          // mouth
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(
            game.player.x + Math.cos(faceAngle) * 5,
            game.player.y + Math.sin(faceAngle) * 5,
            6,
            faceAngle - Math.PI * 0.3,
            faceAngle + Math.PI * 0.3
          );
          ctx.stroke();
        }

        // Shield
        if (game.player.shield) {
          ctx.strokeStyle = "#3498db";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(game.player.x, game.player.y, game.player.radius + 5, 0, Math.PI * 2);
          ctx.stroke();

          const sg = ctx.createRadialGradient(
            game.player.x,
            game.player.y,
            game.player.radius + 3,
            game.player.x,
            game.player.y,
            game.player.radius + 8
          );
          sg.addColorStop(0, "rgba(52, 152, 219, 0.8)");
          sg.addColorStop(1, "rgba(52, 152, 219, 0)");
          ctx.fillStyle = sg;
          ctx.beginPath();
          ctx.arc(game.player.x, game.player.y, game.player.radius + 8, 0, Math.PI * 2);
          ctx.fill();
        }

        // Hearts (top-left HUD)
        for (let i = 0; i < game.player.maxHealth; i++) {
          ctx.fillStyle = i < game.player.health ? "#e74c3c" : "#7f8c8d";
          ctx.beginPath();
          ctx.arc(50 + i * 30, 20, 10, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(50 + i * 30, 20, 12, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Room cleared text
        if (game.roomCleared && game.currentTime - game.roomClearedTime < 3000) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(canvas.width / 2 - 100, 20, 200, 40);

          ctx.fillStyle = "white";
          ctx.font = "20px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Room Cleared!", canvas.width / 2, 50);
        } else if (game.roomCleared) {
          game.roomCleared = false;
        }

        // Game over
        if (game.gameOver) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "white";
          ctx.font = "40px Arial";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);

          ctx.font = "24px Arial";
          ctx.fillText(`Floor: ${game.floor}`, canvas.width / 2, canvas.height / 2);
          ctx.fillText(`Score: ${game.score}`, canvas.width / 2, canvas.height / 2 + 40);

          ctx.font = "20px Arial";
          ctx.fillText("Press R to restart", canvas.width / 2, canvas.height / 2 + 80);
        }
      }

      function getItemPlayerIsStandingOn() {
        for (let i = 0; i < game.items.length; i++) {
          const item = game.items[i];
          const dx = game.player.x - item.x;
          const dy = game.player.y - item.y;
          if (Math.hypot(dx, dy) < game.player.radius + item.radius) {
            return item;
          }
        }
        return null;
        }

      // Loop
      function gameLoop() {
        update();
        render();
        requestAnimationFrame(gameLoop);
      }

      // Start
      initGame();
      gameLoop();
    </script>
  </body>
</html>
